<!DOCTYPE html>
<html prefix="og: https://ogp.me/ns# article: https://ogp.me/ns/article#" lang="en" xml:lang="en">

<head>
    <title>Example-based Tests And Property-based Tests Are Good Friends â€“ Andrea Leopardi</title>
    






<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="description" content="A short look at mixing property-based tests and example-based tests to get the best of both worlds." />
<meta name="author" content="Andrea Leopardi" />

<!-- Favicons -->
<link rel="icon" href="/favicon.ico" sizes="any" />
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon.png" />
<link rel="manifest" href="/manifest.webmanifest" />

<!-- Mobile -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

<!-- Open Graph -->
<meta property="og:title" content="Example-based Tests And Property-based Tests Are Good Friends">
<meta property="og:description" content="A short look at mixing property-based tests and example-based tests to get the best of both worlds.">
<meta property="og:url" content="https://andrealeopardi.com/posts/example-based-tests-and-property-based-tests-are-best-friends/">
<meta property="og:image" content="https://andrealeopardi.com/posts/example-based-tests-and-property-based-tests-are-best-friends/cover-image.jpg">

<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-01-09T00:00:00+00:00">


<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:creator" content="@whatyouhide">
<meta name="twitter:title" content="Example-based Tests And Property-based Tests Are Good Friends">
<meta name="twitter:description" content="A short look at mixing property-based tests and example-based tests to get the best of both worlds.">
<meta name="twitter:image" content="https://andrealeopardi.com/posts/example-based-tests-and-property-based-tests-are-best-friends/cover-image.jpg">


    <!--[if lt IE 9]>
    <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap">
    <link rel="alternate" type="application/rss+xml" title="Andrea Leopardi" href="/feed.xml" />

    
    <link rel="alternate" type="application/rss+xml" title="Andrea Leopardi" href="https://andrealeopardi.com/ feed.xml" />
    

    




<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "url": "https://andrealeopardi.com/posts/example-based-tests-and-property-based-tests-are-best-friends/",
    "author": {
        "@type": "Person",
        "name": "Andrea Leopardi",
        "email": "hi@andrealeopardi.com",
        "url": "https://andrealeopardi.com//about.html"
    },
    "datePublished": "2022-01-09",
    "dateCreated": "2022-01-09",
    "dateModified": "2022-01-09",
    "headline": "Example-based Tests And Property-based Tests Are Good Friends",
    "description": "A short look at mixing property-based tests and example-based tests to get the best of both worlds.",
    "image": "https://andrealeopardi.com/posts/example-based-tests-and-property-based-tests-are-best-friends/cover-image.jpg",
    "inLanguage": {
        "@type": "Language",
        "name": "English"
    }
}
</script>



    <script>
        function createSnowflakes() {
            const snowflakesInARow = 15;
            const snowflakeRows = 12;
            const viewportJiggle = 8;
            const body = document.body;

            for (let row = 0; row < snowflakeRows; row++) {
                for (let col = 0; col < snowflakesInARow; col++) {
                    const snowflake = document.createElement('div');
                    snowflake.classList.add('snowflake');

                    // Random size (scale), rotation, and opacity.
                    const scale = Math.random() * 0.8 + 0.2; // Scale between 0.2 and 1
                    snowflake.style.width = `${50 * scale}px`;
                    snowflake.style.height = `${50 * scale}px`;
                    snowflake.style.transform = `rotate(${Math.random() * 360}deg)`;
                    snowflake.style.opacity = `${Math.random() * 0.1}`; // Opacity between 0.5 and 1

                    // Random position
                    const startLeft = 100 * (col / snowflakesInARow);
                    const startTop = 100 * (row / snowflakeRows);
                    // Jiggle the position a bit to make it look more natural.
                    snowflake.style.left = `${startLeft + Math.random() * viewportJiggle - (viewportJiggle / 2)}vw`;
                    snowflake.style.top = `${startTop + Math.random() * viewportJiggle - (viewportJiggle / 2)}vh`;

                    body.appendChild(snowflake);
                }
            }
        }

        // Re-enable during holidays.
        // document.addEventListener('DOMContentLoaded', createSnowflakes);
    </script>
</head>

<body>
    <div class="wrapper-masthead">
        
        <header>
  <h1 class="site-name">
    <a href="/">

      <picture>
        <source srcset="https://andrealeopardi.com/assets/media/hero-portrait-dark.png"
        media="(prefers-color-scheme: dark)">

        <img class="hero-portrait"
             src="https://andrealeopardi.com/assets/media/hero-portrait.png"
             alt="Portrait of Andrea, daylight, looking to your right" />
      </picture>
      <span>Andrea Leopardi</span>
    </a>
  </h1>
</header>

        

        
<div id="main" role="main" class="container">
  <article class="post">
    <h1>Example-based Tests And Property-based Tests Are Good Friends</h1>

    <div class="entry"><p>I mostly use property-based testing to test stateless functional code. A technique I love to use is to pair property-based tests together with <em>example-based tests</em> (that is, "normal" tests) in order to have some tests that check real input. Let's dive deeper into this technique, some contrived blog-post-adequate examples, and links to real-world examples.</p>
<span id="continue-reading"></span>
<p><img src="https://andrealeopardi.com/posts/example-based-tests-and-property-based-tests-are-best-friends/cover-image.jpg" alt="Cover image of just a bunch of pencils" /></p>
<span class="unsplash-credit">
    Photo by <a href="https:&#x2F;&#x2F;unsplash.com&#x2F;@dtpennington?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">David Pennington</a> on <a href="https://unsplash.com">Unsplash</a>
</span>
<p>I've been a vocal advocate of property-based testing for a while. I wrote <a href="https://github.com/whatyouhide/stream_data"><code>stream_data</code></a>, a property-based testing framework for Elixir, <a href="https://www.youtube.com/watch?v=p84DMv8TQuo">gave talks about the topic</a>, and used property-based testing at work and in my open-source software (such as <a href="https://github.com/whatyouhide/corsica/blob/a4328f6bae1ccdaeb6d9fed14263c5c5a43540a6/test/properties_test.exs">Corsica</a> or <a href="https://github.com/whatyouhide/redix/blob/53216ab4ba96ceceb3e963faca02e2bf25abdb9a/test/redix/protocol_test.exs">Redix</a>).</p>
<p>The most common way I use property-based testing is to test <em>stateless</em> pieces of code. These tend to be the easiest to come up with properties for.</p>
<p>In this short post, I want to talk about one of my favorite techniques to use when writing property-based tests: mixing properties with explicit "example-based" tests. Example-based tests are the tests you're used to, where you have some predefined inputs and expected respective outputs and assert that your code matches the inputs to the outputs.</p>
<p>The idea behind this technique is to combine the ability of property-based testing to test a wide range of input data together with some practical example-based tests that ensure that our code behaves as expected on real inputs.</p>
<h2 id="diving-into-an-example"><a class="zola-anchor" href="#diving-into-an-example" aria-label="Anchor link for: diving-into-an-example">Diving Into an Example</a></h2>
<p>I use this technique quite often. Recently, I used this when writing tests for some JSON-related code in the <a href="https://github.com/elixir-protobuf/protobuf">Protobuf library for Elixir</a> that I help maintain. Let's take this as the main example.</p>
<p>We're writing a function called <code>parse_nanoseconds/1</code> with this spec:</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-variable z-other z-module z-elixir"><span class="z-keyword z-operator z-definition z-constant z-elixir">@</span>spec</span> parse_nanoseconds<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-entity z-name z-class z-elixir">String</span><span class="z-punctuation z-separator z-method z-elixir">.</span>t<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-punctuation z-section z-function z-elixir">)</span><span class="z-punctuation z-section z-function z-elixir">)</span> :: <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-numeric z-elixir">0</span><span class="z-keyword z-operator z-range z-elixir">..</span><span class="z-constant z-numeric z-elixir">999_999_999</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-entity z-name z-class z-elixir">String</span><span class="z-punctuation z-separator z-method z-elixir">.</span>t<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-punctuation z-section z-function z-elixir">)</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span></code></pre>
<p>Its job is to:</p>
<ol>
<li>take a string</li>
<li>extract the leading one to nine digits from it</li>
<li>parse those digits into an integer that represents conventional nanoseconds in a timestamp</li>
<li>return the parsed integer alongside whatever's left of the original string (similar to <a href="https://hexdocs.pm/elixir/Integer.html#parse/1"><code>Integer.parse/2</code></a>)</li>
</ol>
<p>For example, <code>123</code> means 123 <em>milliseconds</em>, so <code>123_000_000</code> nanoseconds. <code>000_001</code> means one microsecond, <code>000_000_001</code> means one nanosecond. You get the idea. By the way, see what I did just now? I just showed you some <strong>examples</strong> of how the function should behave. These make perfect material for our example-based tests.</p>
<h3 id="designing-the-properties"><a class="zola-anchor" href="#designing-the-properties" aria-label="Anchor link for: designing-the-properties">Designing the Properties</a></h3>
<p>Thinking about properties that hold for the output of this function given a valid input, here's what I got.</p>
<ol>
<li>
<p>For valid strings of nine or fewer digits, the output of <code>parse_nanoseconds/1</code> must be an integer in the range <code>0..999_999_999</code>.</p>
</li>
<li>
<p>For any string of nine or fewer digits followed by any string <code>trail</code>, <code>trail</code> should be returned untouched.</p>
</li>
</ol>
<p>I encoded these into a single <code>property</code> test (this uses <code>stream_data</code>):</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-module z-elixir"><span class="z-keyword z-control z-module z-elixir">defmodule</span> <span class="z-entity z-name z-class z-elixir">MyTest</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">use</span> <span class="z-entity z-name z-class z-elixir">ExUnit</span><span class="z-punctuation z-separator z-method z-elixir">.</span><span class="z-entity z-name z-class z-elixir">Case</span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">use</span> <span class="z-entity z-name z-class z-elixir">ExUnitProperties</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  property <span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span>returns valid nanoseconds integer and trailing string<span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span> <span class="z-keyword z-control z-elixir">do</span>
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">    <span class="z-punctuation z-definition z-comment z-elixir">#</span> Generator that generates strings of 1 to 9 digits.
</span></span><span class="z-source z-elixir">    nanos_prefix_gen <span class="z-keyword z-operator z-assignment z-elixir">=</span> string<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-constant z-numeric z-elixir">?0</span><span class="z-keyword z-operator z-range z-elixir">..</span><span class="z-constant z-numeric z-elixir">?9</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">min_length<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-numeric z-elixir">1</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">max_length<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-numeric z-elixir">9</span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">    check all nanos <span class="z-keyword z-operator z-arrow z-elixir">&lt;-</span> nanos_prefix_gen<span class="z-punctuation z-separator z-object z-elixir">,</span>
</span><span class="z-source z-elixir">              rest <span class="z-keyword z-operator z-arrow z-elixir">&lt;-</span> string<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>printable</span><span class="z-punctuation z-section z-function z-elixir">)</span><span class="z-punctuation z-separator z-object z-elixir">,</span>
</span><span class="z-source z-elixir">              string <span class="z-keyword z-operator z-assignment z-elixir">=</span> nanos <span class="z-keyword z-operator z-binary-concatenation z-elixir">&lt;&gt;</span> rest <span class="z-keyword z-control z-elixir">do</span>
</span><span class="z-source z-elixir">      assert <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>parsed_nanos<span class="z-punctuation z-separator z-sequence z-elixir">,</span> parsed_rest<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-assignment z-elixir">=</span> parse_nanoseconds<span class="z-punctuation z-section z-function z-elixir">(</span>string<span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">      assert parsed_nanos <span class="z-keyword z-operator z-elixir">in</span> <span class="z-constant z-numeric z-elixir">0</span><span class="z-keyword z-operator z-range z-elixir">..</span><span class="z-constant z-numeric z-elixir">999_999_999</span>
</span><span class="z-source z-elixir">      assert parse_rest <span class="z-keyword z-operator z-comparison z-elixir">==</span> rest
</span><span class="z-source z-elixir">    <span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>Now for the catch: we can write a bunch of implementations of <code>parse_nanoseconds/1</code> that satisfy this property with no issue, but that are <strong>semantically wrong</strong>. A contrived, slightly-weird, but effective example is below.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir"><span class="z-punctuation z-definition z-comment z-elixir">#</span> Sneaky implementation that is wrong but satisfies our properties:
</span></span><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">parse_nanoseconds</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span>string<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">case</span> <span class="z-entity z-name z-class z-elixir">Regex</span><span class="z-punctuation z-separator z-method z-elixir">.</span>split<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-meta z-string z-elixir"><span class="z-storage z-type z-string z-elixir">~r</span></span><span class="z-meta z-string z-elixir"><span class="z-string z-interpolated z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">/</span><span class="z-constant z-other z-escape-sequence z-regexp z-elixir">\d</span><span class="z-meta z-quantifier z-regexp z-elixir"><span class="z-keyword z-operator z-quantifier z-regexp z-elixir"><span class="z-punctuation z-definition z-quantifier z-begin z-regexp z-elixir">{</span><span class="z-constant z-numeric z-quantifier z-min z-regexp z-elixir">1</span><span class="z-punctuation z-separator z-quantifier z-regexp z-elixir">,</span><span class="z-constant z-numeric z-quantifier z-max z-regexp z-elixir">9</span><span class="z-punctuation z-definition z-quantifier z-end z-regexp z-elixir">}</span></span></span>/</span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> string<span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">parts<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-numeric z-elixir">2</span><span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-elixir">do</span>
</span><span class="z-source z-elixir">    <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span><span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> rest<span class="z-punctuation z-section z-array z-elixir">]</span> <span class="z-keyword z-operator z-arrow z-elixir">-&gt;</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-numeric z-elixir">0</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> rest<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">    _other <span class="z-keyword z-operator z-arrow z-elixir">-&gt;</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>error</span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>The implementation above uses a regex to split the string in two parts on the first occurrence of one to nine digits. The <code>["", rest]</code> match means that the string was split at the start, so a sequence of digits was found at the start. To keep getting weirder, we're just returning <code>0</code> as the nanoseconds. Seems crazy, but guess what? It passes our property. Yeah.</p>
<h3 id="reintroducing-example-based-tests"><a class="zola-anchor" href="#reintroducing-example-based-tests" aria-label="Anchor link for: reintroducing-example-based-tests">Reintroducing Example-Based Tests</a></h3>
<p>Are property-based tests bad? Should we go back to example-based tests and curse the day we thought to use something cool? Well, what I like to do is reintroduce example-based tests to save the day but keep the property-based tests to get all the benefits from those.</p>
<p>I turned the property above into this:</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir">property <span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span>returns a valid nanoseconds integer and the trailing string<span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span> <span class="z-keyword z-control z-elixir">do</span>
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">  <span class="z-punctuation z-definition z-comment z-elixir">#</span> Example-based part:
</span></span><span class="z-source z-elixir">  assert parse_nanoseconds<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span>123foo<span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span><span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-operator z-comparison z-elixir">==</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-numeric z-elixir">123_000_000</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span>foo<span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">  assert parse_nanoseconds<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span>000000001<span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span><span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-operator z-comparison z-elixir">==</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-numeric z-elixir">1</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span><span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">  <span class="z-punctuation z-definition z-comment z-elixir">#</span> Property part (unchanged):
</span></span><span class="z-source z-elixir">  nanos_prefix_gen <span class="z-keyword z-operator z-assignment z-elixir">=</span> string<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-constant z-numeric z-elixir">?0</span><span class="z-keyword z-operator z-range z-elixir">..</span><span class="z-constant z-numeric z-elixir">?9</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">min_length<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-numeric z-elixir">1</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">max_length<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-numeric z-elixir">9</span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  check all nanos <span class="z-keyword z-operator z-arrow z-elixir">&lt;-</span> nanos_prefix_gen<span class="z-punctuation z-separator z-object z-elixir">,</span>
</span><span class="z-source z-elixir">            rest <span class="z-keyword z-operator z-arrow z-elixir">&lt;-</span> string<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>printable</span><span class="z-punctuation z-section z-function z-elixir">)</span><span class="z-punctuation z-separator z-object z-elixir">,</span>
</span><span class="z-source z-elixir">            string <span class="z-keyword z-operator z-assignment z-elixir">=</span> nanos <span class="z-keyword z-operator z-binary-concatenation z-elixir">&lt;&gt;</span> rest <span class="z-keyword z-control z-elixir">do</span>
</span><span class="z-source z-elixir">    assert <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>parsed_nanos<span class="z-punctuation z-separator z-sequence z-elixir">,</span> parsed_rest<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-assignment z-elixir">=</span> parse_nanoseconds<span class="z-punctuation z-section z-function z-elixir">(</span>string<span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">    assert parsed_nanos <span class="z-keyword z-operator z-elixir">in</span> <span class="z-constant z-numeric z-elixir">0</span><span class="z-keyword z-operator z-range z-elixir">..</span><span class="z-constant z-numeric z-elixir">999_999_999</span>
</span><span class="z-source z-elixir">    assert parse_rest <span class="z-keyword z-operator z-comparison z-elixir">==</span> rest
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>With just a couple of example-based assertions thrown in there, the bogus implementation crumbles and fails miserably.</p>
<p>I sometimes keep the example-based assertions in the <code>property</code> itself and other times prefer to split them up, but the principle stays the same.</p>
<h3 id="regressions"><a class="zola-anchor" href="#regressions" aria-label="Anchor link for: regressions">Regressions</a></h3>
<p>Another fantastic use case for using example-based tests together with property-based tests is testing <strong>regressions</strong>. <code>stream_data</code> (and I'm sure other property-based testing frameworks) often gets feature requests to specify some explicit values in generators. This way, users can be sure that the property they're encoding will go through some known values that are likely to create issues because of the domain or that caused regressions in the past. My answer is always that this is exactly where the technique described in this blog post comes in handy. You can write your property and pair it up with example-based tests that test your explicit values.</p>
<h2 id="conclusion"><a class="zola-anchor" href="#conclusion" aria-label="Anchor link for: conclusion">Conclusion</a></h2>
<p>This technique is simple, but I find it effective and practical. You get the benefits of property-based testing, like covering a wide range of inputs and discovering unhandled corner cases, but pair those with some practical examples. Those can provide you with some "sanity checks" to have at least some confidence that your code is doing what it's supposed to on real-world examples. Those example-based tests can also cover well-known "problematic" values of your input space as well as regressions.</p>
<p>If you are curious about actual examples, go look at the <a href="https://github.com/elixir-protobuf/protobuf/blob/00144b3a08aac7a38e3e9774a438dcc7da3d8bc7/test/protobuf/json/utils_test.exs">actual tests in the Protobuf library</a>.</p>
<p>I wrote a bit more about this technique and in general about property-based testing in <a href="https://pragprog.com/titles/lmelixir/testing-elixir/">Testing Elixir</a>, the Pragmatic Programmers book I co-authored with Jeffrey Matthias.</p>
</div>

    <time class="posted-at" datetime="2022-01-09">
      Written on January  9, 2022
      
    </time>

    <script src="https://giscus.app/client.js"
        data-repo="whatyouhide/whatyouhide.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkxODQwNDQxNzQ="
        data-category="General"
        data-category-id="DIC_kwDOCvhKjs4CY-gd"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
  </article>
</div>


        <footer>
    <div class="icons">
        <a href="mailto:hi@andrealeopardi.com">
            <picture>
              <img id="icon-email"
                   class="footer-icon"
                   src="/assets/icons/email.png"
                   alt="Hand-drawn icon of a letter envelope"
                   title="Email" />
            </picture>
        </a>

        <a href="https://github.com/whatyouhide" target="_blank">
            <picture>
              <img id="icon-github"
                   class="footer-icon"
                   src="/assets/icons/github.png"
                   alt="Hand-drawn icon of the GitHub logo"
                   title="GitHub" />
            </picture>
        </a>

        <a href="https://twitter.com/whatyouhide" target="_blank">
            <picture>
              <img id="icon-twitter"
                   class="footer-icon"
                   src="/assets/icons/twitter.png"
                   alt="Hand-drawn icon of the Twitter logo"
                   title="Twitter" />
            </picture>
        </a>

        <a href="/feed.xml">
            <picture>
              <img id="icon-rss"
                   class="footer-icon"
                   src="/assets/icons/rss.png"
                   alt="Hand-drawn icon of the RSS logo"
                   title="RSS feed" />
            </picture>
        </a>
    </div>
</footer>

    </div>
</body>

</html>
