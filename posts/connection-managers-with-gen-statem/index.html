<!DOCTYPE html>
<html prefix="og: https://ogp.me/ns# article: https://ogp.me/ns/article#" lang="en" xml:lang="en">

<head>
    <title>Persistent connections with gen_statem – Andrea Leopardi</title>
    






<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="description" content="How we can use the gen_statem behaviour to implement a resilient state machine that holds a connection to an external service." />
<meta name="author" content="Andrea Leopardi" />

<!-- Favicons -->
<link rel="icon" href="/favicon.ico" sizes="any" />
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon.png" />
<link rel="manifest" href="/manifest.webmanifest" />

<!-- Mobile -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

<!-- Open Graph -->
<meta property="og:title" content="Persistent connections with gen_statem">
<meta property="og:description" content="How we can use the gen_statem behaviour to implement a resilient state machine that holds a connection to an external service.">
<meta property="og:url" content="https://andrealeopardi.com/posts/connection-managers-with-gen-statem/">
<meta property="og:image" content="https://andrealeopardi.com/posts/connection-managers-with-gen-statem/cover-image.jpg">

<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-04-14T00:00:00+00:00">


<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:creator" content="@whatyouhide">
<meta name="twitter:title" content="Persistent connections with gen_statem">
<meta name="twitter:description" content="How we can use the gen_statem behaviour to implement a resilient state machine that holds a connection to an external service.">
<meta name="twitter:image" content="https://andrealeopardi.com/posts/connection-managers-with-gen-statem/cover-image.jpg">


    <!--[if lt IE 9]>
    <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap">
    <link rel="alternate" type="application/rss+xml" title="Andrea Leopardi" href="/feed.xml" />

    
    <link rel="alternate" type="application/rss+xml" title="Andrea Leopardi" href="https://andrealeopardi.com/ feed.xml" />
    

    




<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "url": "https://andrealeopardi.com/posts/connection-managers-with-gen-statem/",
    "author": {
        "@type": "Person",
        "name": "Andrea Leopardi",
        "email": "hi@andrealeopardi.com",
        "url": "https://andrealeopardi.com//about.html"
    },
    "datePublished": "2019-04-14",
    "dateCreated": "2019-04-14",
    "dateModified": "2019-04-14",
    "headline": "Persistent connections with gen_statem",
    "description": "How we can use the gen_statem behaviour to implement a resilient state machine that holds a connection to an external service.",
    "image": "https://andrealeopardi.com/posts/connection-managers-with-gen-statem/cover-image.jpg",
    "inLanguage": {
        "@type": "Language",
        "name": "English"
    }
}
</script>



    <script>
        function createSnowflakes() {
            const snowflakesInARow = 15;
            const snowflakeRows = 12;
            const viewportJiggle = 8;
            const body = document.body;

            for (let row = 0; row < snowflakeRows; row++) {
                for (let col = 0; col < snowflakesInARow; col++) {
                    const snowflake = document.createElement('div');
                    snowflake.classList.add('snowflake');

                    // Random size (scale), rotation, and opacity.
                    const scale = Math.random() * 0.8 + 0.2; // Scale between 0.2 and 1
                    snowflake.style.width = `${50 * scale}px`;
                    snowflake.style.height = `${50 * scale}px`;
                    snowflake.style.transform = `rotate(${Math.random() * 360}deg)`;
                    snowflake.style.opacity = `${Math.random() * 0.1}`; // Opacity between 0.5 and 1

                    // Random position
                    const startLeft = 100 * (col / snowflakesInARow);
                    const startTop = 100 * (row / snowflakeRows);
                    // Jiggle the position a bit to make it look more natural.
                    snowflake.style.left = `${startLeft + Math.random() * viewportJiggle - (viewportJiggle / 2)}vw`;
                    snowflake.style.top = `${startTop + Math.random() * viewportJiggle - (viewportJiggle / 2)}vh`;

                    body.appendChild(snowflake);
                }
            }
        }

        // Re-enable during holidays.
        // document.addEventListener('DOMContentLoaded', createSnowflakes);
    </script>
</head>

<body>
    <div class="wrapper-masthead">
        
        <header>
  <h1 class="site-name">
    <a href="/">

      <picture>
        <source srcset="https://andrealeopardi.com/assets/media/hero-portrait-dark.png"
        media="(prefers-color-scheme: dark)">

        <img class="hero-portrait"
             src="https://andrealeopardi.com/assets/media/hero-portrait.png"
             alt="Portrait of Andrea, daylight, looking to your right" />
      </picture>
      <span>Andrea Leopardi</span>
    </a>
  </h1>
</header>

        

        
<div id="main" role="main" class="container">
  <article class="post">
    <h1>Persistent connections with gen_statem</h1>

    <div class="entry"><p>Our applications often interact with external systems. In many cases, we need a <em>persistent</em> connection to one or more of these external services. For example, if your application makes continuous use of a database, you'll likely want to stay connected to such database so that you can avoid spending time and resources connecting and disconnecting each time you perform a request. With Erlang and Elixir, the natural abstraction to maintain a persistent connection is a process. In this post, we'll have a look at how we can take advantage of the <code>gen_statem</code> behaviour to write state machine processes that act as persistent connections to external systems.</p>
<span id="continue-reading"></span>
<p><img src="https://andrealeopardi.com/posts/connection-managers-with-gen-statem/cover-image.jpg" alt="Cover image of a electricity" /></p>
<span class="unsplash-credit">
    Photo by <a href="https:&#x2F;&#x2F;unsplash.com&#x2F;photos&#x2F;ImcUkZ72oUs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Israel Palacio</a> on <a href="https://unsplash.com">Unsplash</a>
</span>
<p>This article is an evolution of a previous article posted on this blog, <a href="https://andrealeopardi.com/posts/handling-tcp-connections-in-elixir">"Handling TCP connections in Elixir"</a>. In that article, I describe how to build a connection process that talks to a Redis server over TCP. Instead of <code>gen_statem</code> (which wasn't available at that time), I use the <a href="https://github.com/fishcakez/connection">connection</a> library by James Fish, but the concepts are similar. If you're interested in the TCP interactions more than you are in <code>gen_statem</code>, read that article first. What I describe here is an evolution of the old implementation that doesn't require external dependencies and that nicely shows a practical use case for many of the features that <code>gen_statem</code> provides.</p>
<p><em>Note</em>: I'm more used to Elixir and its syntax, so that's what I'm going to use here. However, I won't use almost any Elixir-specific features, so the article should also be readable for folks that are more comfortable with Erlang. If you want to follow along with the finished Erlang code for the state machine we'll build, look at <a href="https://gist.github.com/whatyouhide/e7531e10128af58b9830af8938eae478">the Gist</a> containing the final implementation in Elixir and Erlang.</p>
<h2 id="the-connection-manager"><a class="zola-anchor" href="#the-connection-manager" aria-label="Anchor link for: the-connection-manager">The connection "manager"</a></h2>
<p>During the blog post, we'll build a connection process that maintains a persistent TCP connection to a database.</p>
<p>It's important to understand the design and purpose of our connection process. This process is not the connection to the database itself but only a <em>wrapper</em> around the connection. This means that if the connection itself goes down, our process should stay alive and try to reconnect while replying with errors to clients that try to make requests. While a catchphrase of the Erlang and Elixir world is "let it crash", erroneous conditions such as the TCP connection going down are known in advance and our system should strive to be resilient when they happen. TCP errors are not errors for our connection process, they're just another event happening in the system. This design decision is a powerful one because it leads us to a stable and resilient process that our system can rely on, regardless of the state of the actual connection.</p>
<p>A side effect of the design of the connection process so that it's independent of the state of the connection is that we don't need to establish the TCP connection synchronously when starting up our process. We can start our connection process and return a PID right away, start establishing the connection in the background, and then act as if the connection is "broken" until the connection is established. After all, our connection process and application will need to deal with the connection being broken at some point, so there's often no reason to require synchronous connecting.</p>
<p>The ideas briefly mentioned above come from an article by Fred Hebert, <a href="https://ferd.ca/it-s-about-the-guarantees.html">"It's about the guarantees"</a>, which does a great job at explaining why the design I discussed works well especially in Erlang and Elixir applications.</p>
<h2 id="gen-statem-primer"><a class="zola-anchor" href="#gen-statem-primer" aria-label="Anchor link for: gen-statem-primer"><code>gen_statem</code> primer</a></h2>
<p><a href="http://erlang.org/doc/man/gen_statem.html"><code>gen_statem</code></a> is an OTP behaviour (like <code>GenServer</code>) that was introduced in OTP 19. Like its name suggests, it's an abstraction over a state machine. A common example of a state machine is an ATM:</p>
<p><img src="https://andrealeopardi.com/posts/connection-managers-with-gen-statem/atm-state-machine-diagram.png" alt="ATM state machine diagram" /></p>
<p>There are states that the ATM can be in (like <code>waiting_for_pin</code> or <code>requesting_cash</code>) and events that cause state transitions, that is, moving from one state to another state (or to the same state).</p>
<p><code>gen_statem</code> mirrors the design of a state machine very closely. Essentially, you have something similar to a GenServer, where you have callbacks and events like user calls or messages. In a <code>gen_statem</code> module, however, you have a state which represents the state machine's state and a <code>data</code> term that represents information that the state machine is carrying around. The "data" in a <code>gen_statem</code> is what we usually call the "state" in a GenServer (this is confusing, bear with me).</p>
<p>The <code>gen_statem</code> states are represented through functions: in the ATM machine, you would have a <code>waiting_for_pin/3</code> function (with one or more clauses) to handle events in the <code>waiting_for_pin</code> state, and so on for the other states. The return value of state functions determines what the state machine should do next and looks something like this:</p>
<ul>
<li>
<p><code>{:next_state, next_state, new_data, actions}</code> to transition to the next state <code>next_state</code>. <code>new_data</code> is the new data of the state machine and <code>actions</code> is a list of actions, like firing off internal events, setting up timers, or replying to calls. We'll have a better understanding of actions as we go along.</p>
</li>
<li>
<p><code>{:keep_state, new_data, actions}</code> to remain in the same state. <code>new_data</code> and <code>actions</code> are the same as described for <code>:next_state</code>.</p>
</li>
</ul>
<p>The API that <code>:gen_statem</code> exposes is actually a bit complex. A symptom of this is that there are many more return values than the two mentioned above, but most of them end up being simplifications of these two. For example, you can return <code>{:keep_state, new_data}</code> instead of <code>{:keep_state, new_data, []}</code> if you don't want to execute any actions. We'll try to use whatever fits best in each instance.</p>
<h2 id="it-s-all-about-the-connection"><a class="zola-anchor" href="#it-s-all-about-the-connection" aria-label="Anchor link for: it-s-all-about-the-connection">It's all about the connection</a></h2>
<p>We're going to use TCP with <code>:gen_tcp</code> to connect to the database. We'll send requests through the socket and then asynchronously receive responses from the database. The clients calling our connections will wait synchronously on responses to the requests that they sent, but our connection will be able to handle multiple requests from different clients concurrently. We'll assume our fictional database has a protocol that expects each request to have an ID and that tags each response with the ID of the corresponding request. This will allow our state machine to maintain a map of request ID to requesting process for in-flight requests. When a response arrives, we can retrieve the caller waiting for it from this map.</p>
<h3 id="designing-the-state-machine"><a class="zola-anchor" href="#designing-the-state-machine" aria-label="Anchor link for: designing-the-state-machine">Designing the state machine</a></h3>
<p>Let's start with designing the states of our connection. We already figured out that there's going to be a <code>disconnected</code> state for when the TCP connection is down. This will also be the starting state since we'll start as <code>disconnected</code> and then try to connect the first time as mentioned at the beginning of the article. We only need one more state, the <code>connected</code> state, for when the TCP connection is alive and well. The next step when designing the state machine is figuring out what events cause the state machine to transition from one state to another. In our case, we can think of these events causing state transitions:</p>
<ul>
<li>
<p>The TCP connection goes down — this makes the state machine transition from the <code>connected</code> state to the <code>disconnected</code> state.</p>
</li>
<li>
<p>The TCP connection is established successfully — this makes the state machine from <code>disconnected</code> to <code>connected</code>.</p>
</li>
</ul>
<p>Then, we have events that don't cause state transition. In our case, that's only requests from clients.</p>
<p>A helpful habit when designing state machines is to draw a diagram of the state machine. This lets us visualize the states and state transitions at a glance.</p>
<p><img src="https://andrealeopardi.com/posts/connection-managers-with-gen-statem/connection-state-machine-diagram.png" alt="Connection state machine diagram" /></p>
<h3 id="implementing-the-state-machine"><a class="zola-anchor" href="#implementing-the-state-machine" aria-label="Anchor link for: implementing-the-state-machine">Implementing the state machine</a></h3>
<p>Let's turn this diagram into a functioning <code>gen_statem</code>. The first thing to do is to create a <code>Connection</code> module and specify that it's an implementation of the <code>:gen_statem</code> behaviour. We'll also define an internal struct that we'll use as the data carried by the state machine. The data will contain the host and port to connect/reconnect to, the TCP socket, and a map of request ID to caller waiting for a response.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-module z-elixir"><span class="z-keyword z-control z-module z-elixir">defmodule</span> <span class="z-entity z-name z-class z-elixir">Connection</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-variable z-other z-module z-elixir"><span class="z-keyword z-operator z-definition z-constant z-elixir">@</span>behaviour</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_statem</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">defstruct</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>host</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>port</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>socket</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">requests<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">  <span class="z-punctuation z-definition z-comment z-elixir">#</span> Ignore this for now. We&#39;ll see what this is about later on.
</span></span><span class="z-source z-elixir">  <span class="z-variable z-other z-module z-elixir"><span class="z-keyword z-operator z-definition z-constant z-elixir">@</span>impl</span> <span class="z-constant z-language z-elixir">true</span>
</span><span class="z-source z-elixir"><span class="z-meta z-function z-elixir">  <span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">callback_mode</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">    <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>state_functions</span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir"><span class="z-meta z-function z-elixir">  <span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">start_link</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span>opts<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">    host <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-entity z-name z-class z-elixir">Keyword</span><span class="z-punctuation z-separator z-method z-elixir">.</span>fetch!<span class="z-punctuation z-section z-function z-elixir">(</span>opts<span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>host</span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">    port <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-entity z-name z-class z-elixir">Keyword</span><span class="z-punctuation z-separator z-method z-elixir">.</span>fetch!<span class="z-punctuation z-section z-function z-elixir">(</span>opts<span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>port</span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">    <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_statem</span><span class="z-punctuation z-separator z-method z-elixir">.</span>start_link<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-variable z-language z-elixir">__MODULE__</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-entity z-name z-class z-elixir">String</span><span class="z-punctuation z-separator z-method z-elixir">.</span>to_charlist<span class="z-punctuation z-section z-function z-elixir">(</span>host<span class="z-punctuation z-section z-function z-elixir">)</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> port<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-punctuation z-section z-array z-elixir">]</span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>As we mentioned, the state machine starts in the <code>disconnected</code> state. Similarly to a GenServer, when you start the state machine process, <code>start_link</code> won't return until the <code>init/1</code> callback that both <code>GenServer</code> and <code>gen_statem</code> provide returns. We want to return from <code>init/1</code> right away and then establish the connection in the background. <code>gen_statem</code> provides us with a perfect tool for this: <strong>internal events</strong>. In our case, we can return from <code>init/1</code> right away and generate an internal <code>:connect</code> event that tells the state machine to initiate connection. Let's start with implementing the <code>init/1</code> callback.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">init</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>host<span class="z-punctuation z-separator z-sequence z-elixir">,</span> port<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  data <span class="z-keyword z-operator z-assignment z-elixir">=</span> %<span class="z-variable z-language z-elixir">__MODULE__</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-keywords z-elixir">host<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> host<span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">port<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> port<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">  actions <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_event</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>internal</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connect</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">  <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>ok</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>disconnected</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> data<span class="z-punctuation z-separator z-sequence z-elixir">,</span> actions<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>As you can see, the return value of <code>init/1</code> specifies that the first state to transition to is the <code>:disconnected</code> state. The only action we want to execute is <code>:next_event</code> which fires off an event. Events have a type and a term attached to them. For example, an Elixir message coming to the state machine process has the event type as <code>:info</code> and the term as the message itself. In our case, we fire off an internal event that has the type <code>:internal</code> and the term <code>:connect</code>.</p>
<p>The state machine states are implemented as functions named as the state. So in our case, the first function to implement is <code>disconnect/3</code>. State functions are called with the event type as the first argument, the event term as the second argument, and the data as the third argument.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">disconnected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>internal</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connect</span><span class="z-punctuation z-separator z-object z-elixir">,</span> data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">  <span class="z-punctuation z-definition z-comment z-elixir">#</span> We use the socket in active mode for simplicity, but
</span></span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">  <span class="z-punctuation z-definition z-comment z-elixir">#</span> it&#39;s often better to use &quot;active: :once&quot; for better control.
</span></span><span class="z-source z-elixir">  socket_opts <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>binary</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">active<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-language z-elixir">true</span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">case</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_tcp</span><span class="z-punctuation z-separator z-method z-elixir">.</span>connect<span class="z-punctuation z-section z-function z-elixir">(</span>data<span class="z-punctuation z-separator z-method z-elixir">.</span>host<span class="z-punctuation z-separator z-object z-elixir">,</span> data<span class="z-punctuation z-separator z-method z-elixir">.</span>port<span class="z-punctuation z-separator z-object z-elixir">,</span> socket_opts<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-elixir">do</span>
</span><span class="z-source z-elixir">    <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>ok</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> socket<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-arrow z-elixir">-&gt;</span>
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">      <span class="z-punctuation z-definition z-comment z-elixir">#</span> We omit the actions as there are none.
</span></span><span class="z-source z-elixir">      <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_state</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connected</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>data <span class="z-keyword z-operator z-other z-elixir">|</span> <span class="z-constant z-other z-keywords z-elixir">socket<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> socket<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">    <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>error</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> error<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-arrow z-elixir">-&gt;</span>
</span><span class="z-source z-elixir">      <span class="z-entity z-name z-class z-elixir">Logger</span><span class="z-punctuation z-separator z-method z-elixir">.</span>error<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span>Connection failed: </span></span></span><span class="z-source z-elixir"><span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-source z-elixir"><span class="z-meta z-string z-elixir"><span class="z-meta z-interpolation z-elixir"><span class="z-punctuation z-section z-interpolation z-begin z-elixir">#{</span></span></span></span></span></span></span><span class="z-source z-elixir"><span class="z-meta z-string z-elixir"><span class="z-meta z-interpolation z-elixir"><span class="z-source z-elixir z-embedded"><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>inet</span><span class="z-punctuation z-separator z-method z-elixir">.</span>format_error<span class="z-punctuation z-section z-function z-elixir">(</span>error<span class="z-punctuation z-section z-function z-elixir">)</span></span><span class="z-punctuation z-section z-interpolation z-end z-elixir">}</span></span></span></span><span class="z-source z-elixir"><span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">      <span class="z-punctuation z-definition z-comment z-elixir">#</span> This is the same as {:keep_state, data, actions} but makes it clear
</span></span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">      <span class="z-punctuation z-definition z-comment z-elixir">#</span> we&#39;re not changing the data.
</span></span><span class="z-source z-elixir">      actions <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_event</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>internal</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connect</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">      <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>keep_state_and_data</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> actions<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>If the connection is established successfully, we store the socket in the data and move to the <code>:connected</code> state. If there's an error connecting, we stay in the <code>:disconnected</code> state with the same data and fire the internal <code>:connect</code> event again. This means that we'll try to reconnect right away and might end up in a failed connection loop. We'll fix this later on by introducing back-offs.</p>
<p>Now that we're in the <code>:connected</code> state, let's handle the connection going down so that we'll have all the state <em>transitions</em>. Since our TCP socket is in active mode, we'll get a <code>{:tcp_closed, socket}</code> message when the connection goes down (let's ignore <code>{:tcp_error, socket, reason}</code> for now).</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">connected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>info</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>tcp_closed</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> socket<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-keywords z-elixir">socket<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> socket<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-assignment z-elixir">=</span> data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  disconnect<span class="z-punctuation z-section z-function z-elixir">(</span>data<span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir"><span class="z-punctuation z-definition z-comment z-elixir">#</span> Let&#39;s use a helper function, it will come in handy later.
</span></span><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">defp</span> <span class="z-entity z-name z-function z-private z-elixir">disconnect</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span>data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-entity z-name z-class z-elixir">Logger</span><span class="z-punctuation z-separator z-method z-elixir">.</span>error<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span>Connection closed<span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">  data <span class="z-keyword z-operator z-assignment z-elixir">=</span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>data <span class="z-keyword z-operator z-other z-elixir">|</span> <span class="z-constant z-other z-keywords z-elixir">socket<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-language z-elixir">nil</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">  actions <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_event</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>internal</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connect</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">  <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_state</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>disconnected</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> data<span class="z-punctuation z-separator z-sequence z-elixir">,</span> actions<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>We return to the <code>:disconnected</code> state and immediately fire off an internal <code>:connect</code> event so that we'll try to re-establish the connection right away. This is the same as what happens when we can't connect for now.</p>
<h3 id="handling-requests"><a class="zola-anchor" href="#handling-requests" aria-label="Anchor link for: handling-requests">Handling requests</a></h3>
<p>Now, we need to handle requests from clients and data coming back from the database. These requests will be made through <code>request/2</code>:</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">request</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span>pid<span class="z-punctuation z-separator z-object z-elixir">,</span> request<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_statem</span><span class="z-punctuation z-separator z-method z-elixir">.</span>call<span class="z-punctuation z-section z-function z-elixir">(</span>pid<span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>request</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> request<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>The event type that results from a <code>:gen_statem.call/2</code> call is <code>{:call, from}</code>. <code>from</code> identifies the caller, similarly to the <code>from</code> argument in <code>handle_call/3</code> for GenServers. The event content is the request itself, in our case <code>{:request, request}</code>.</p>
<p>A request can come in either the <code>:connected</code> or the <code>:disconnected</code> state and it never causes a state transition. When a request comes in the <code>:disconnected</code> state, we reply with <code>{:error, :disconnected}</code> right away. Replying is another <em>action</em> that we can perform.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">disconnected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>call</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> from<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>request</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> request<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  actions <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>reply</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> from<span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>error</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>disconnected</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">  <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>keep_state_and_data</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> actions<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>When a request comes in the <code>:connected</code> state, we issue the request to the database and store the caller under the request ID in our request map. <code>request</code> here could be anything, but let's imagine it's a map that contains a <code>:id</code> key holding the ID of the request. If there's an error sending, we close the socket and go back to the disconnected state.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">connected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>call</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> from<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>request</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> request<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">case</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_tcp</span><span class="z-punctuation z-separator z-method z-elixir">.</span>send<span class="z-punctuation z-section z-function z-elixir">(</span>data<span class="z-punctuation z-separator z-method z-elixir">.</span>socket<span class="z-punctuation z-separator z-object z-elixir">,</span> encode_request<span class="z-punctuation z-section z-function z-elixir">(</span>request<span class="z-punctuation z-section z-function z-elixir">)</span><span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-elixir">do</span>
</span><span class="z-source z-elixir">    <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>ok</span> <span class="z-keyword z-operator z-arrow z-elixir">-&gt;</span>
</span><span class="z-source z-elixir">      data <span class="z-keyword z-operator z-assignment z-elixir">=</span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>data <span class="z-keyword z-operator z-other z-elixir">|</span> <span class="z-constant z-other z-keywords z-elixir">requests<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-entity z-name z-class z-elixir">Map</span><span class="z-punctuation z-separator z-method z-elixir">.</span>put<span class="z-punctuation z-section z-function z-elixir">(</span>data<span class="z-punctuation z-separator z-method z-elixir">.</span>requests<span class="z-punctuation z-separator z-sequence z-elixir">,</span> request<span class="z-punctuation z-separator z-method z-elixir">.</span>id<span class="z-punctuation z-separator z-sequence z-elixir">,</span> from<span class="z-punctuation z-section z-function z-elixir">)</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">      <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>keep_state</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> data<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">    <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>error</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> _reason<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-arrow z-elixir">-&gt;</span>
</span><span class="z-source z-elixir">      <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>ok</span> <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_tcp</span><span class="z-punctuation z-separator z-method z-elixir">.</span>close<span class="z-punctuation z-section z-function z-elixir">(</span>socket<span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">      disconnect<span class="z-punctuation z-section z-function z-elixir">(</span>data<span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>Since our TCP socket is in active mode, packets sent by the database will arrive as messages to the state machine. A <code>{:tcp, socket, data}</code> message can only come in the <code>:connected</code> state, so we can skip the additional <code>disconnected/3</code> clause to handle TCP packets. For simplicity, we're going to assume that a packet always contains a single complete response so that we can avoid buffering.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">connected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>info</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>tcp</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> socket<span class="z-punctuation z-separator z-sequence z-elixir">,</span> packet<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-keywords z-elixir">socket<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> socket<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-assignment z-elixir">=</span> data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  response <span class="z-keyword z-operator z-assignment z-elixir">=</span> decode_response<span class="z-punctuation z-section z-function z-elixir">(</span>packet<span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">  <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>from<span class="z-punctuation z-separator z-sequence z-elixir">,</span> requests<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-entity z-name z-class z-elixir">Map</span><span class="z-punctuation z-separator z-method z-elixir">.</span>pop<span class="z-punctuation z-section z-function z-elixir">(</span>data<span class="z-punctuation z-separator z-method z-elixir">.</span>requests<span class="z-punctuation z-separator z-object z-elixir">,</span> response<span class="z-punctuation z-separator z-method z-elixir">.</span>id<span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">  <span class="z-punctuation z-definition z-comment z-elixir">#</span> :gen_statem.reply/2 can be used to manually reply to a
</span></span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">  <span class="z-punctuation z-definition z-comment z-elixir">#</span> :gen_statem.call/2 (similarly to GenServer.reply/2).
</span></span><span class="z-source z-elixir">  <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_statem</span><span class="z-punctuation z-separator z-method z-elixir">.</span>reply<span class="z-punctuation z-section z-function z-elixir">(</span>from<span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>ok</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> response<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>keep_state</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>data <span class="z-keyword z-operator z-other z-elixir">|</span> <span class="z-constant z-other z-keywords z-elixir">requests<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> requests<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<h3 id="performing-actions-when-entering-a-state"><a class="zola-anchor" href="#performing-actions-when-entering-a-state" aria-label="Anchor link for: performing-actions-when-entering-a-state">Performing actions when entering a state</a></h3>
<p>You might notice there's a bug in our implementation: when we disconnect, we don't notify the clients that are waiting for a response. To do that, we can modify the <code>disconnect/1</code> helper function:</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">defp</span> <span class="z-entity z-name z-function z-private z-elixir">disconnect</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span>data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-entity z-name z-class z-elixir">Logger</span><span class="z-punctuation z-separator z-method z-elixir">.</span>error<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span>Connection closed<span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  <span class="z-entity z-name z-class z-elixir">Enum</span><span class="z-punctuation z-separator z-method z-elixir">.</span>each<span class="z-punctuation z-section z-function z-elixir">(</span>data<span class="z-punctuation z-separator z-method z-elixir">.</span>requests<span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-keyword z-control z-elixir">fn</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>_id<span class="z-punctuation z-separator z-sequence z-elixir">,</span> from<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-other z-elixir">-&gt;</span>
</span><span class="z-source z-elixir">    <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_statem</span><span class="z-punctuation z-separator z-method z-elixir">.</span>reply<span class="z-punctuation z-section z-function z-elixir">(</span>from<span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>error</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>disconnected</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  data <span class="z-keyword z-operator z-assignment z-elixir">=</span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>data <span class="z-keyword z-operator z-other z-elixir">|</span> <span class="z-constant z-other z-keywords z-elixir">socket<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-language z-elixir">nil</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">requests<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  actions <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_event</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>internal</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connect</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">  <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_state</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>disconnected</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> data<span class="z-punctuation z-separator z-sequence z-elixir">,</span> actions<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>This works, but <code>:gen_statem</code> provides a possibly better way to perform common clean up code when disconnecting: state enter events. It's enough to change the <code>callback_mode/0</code> callback we implemented initially:</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-variable z-other z-module z-elixir"><span class="z-keyword z-operator z-definition z-constant z-elixir">@</span>impl</span> <span class="z-constant z-language z-elixir">true</span>
</span><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">callback_mode</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>state_functions</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>state_enter</span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>Now, <code>:gen_statem</code> will call <code>new_state(:enter, old_state, data)</code> every time the state machine transitions from <code>old_state</code> to <code>new_state</code>. If we transition from <code>:connected</code> to <code>:disconnected</code> then <code>disconnected(:enter, :connected, data)</code> will be called. This is ideal for our use case, as we can now remove the <code>disconnect/1</code> helper function and implement the <code>disconnected/3</code> clause that handles the <code>:enter</code> event.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">disconnected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>enter</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connected</span><span class="z-punctuation z-separator z-object z-elixir">,</span> data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-entity z-name z-class z-elixir">Logger</span><span class="z-punctuation z-separator z-method z-elixir">.</span>error<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-meta z-string z-elixir"><span class="z-string z-quoted z-double z-elixir"><span class="z-punctuation z-definition z-string z-begin z-elixir">&quot;</span>Connection closed<span class="z-punctuation z-definition z-string z-end z-elixir">&quot;</span></span></span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  <span class="z-entity z-name z-class z-elixir">Enum</span><span class="z-punctuation z-separator z-method z-elixir">.</span>each<span class="z-punctuation z-section z-function z-elixir">(</span>data<span class="z-punctuation z-separator z-method z-elixir">.</span>requests<span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-keyword z-control z-elixir">fn</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>_id<span class="z-punctuation z-separator z-sequence z-elixir">,</span> from<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-other z-elixir">-&gt;</span>
</span><span class="z-source z-elixir">    <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_statem</span><span class="z-punctuation z-separator z-method z-elixir">.</span>reply<span class="z-punctuation z-section z-function z-elixir">(</span>from<span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>error</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>disconnected</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  data <span class="z-keyword z-operator z-assignment z-elixir">=</span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span>data <span class="z-keyword z-operator z-other z-elixir">|</span> <span class="z-constant z-other z-keywords z-elixir">socket<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-language z-elixir">nil</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">requests<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> %<span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  actions <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_event</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>internal</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connect</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">  <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_state</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>disconnected</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> data<span class="z-punctuation z-separator z-sequence z-elixir">,</span> actions<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>This allows us to just move to the disconnected state when we want to disconnect, and the state enter clause will take care of replying to waiting clients and cleaning the data up. Note that since <code>:disconnected</code> is our first state, the <code>:enter</code> event will fire the first time with the old state being <code>:disconnected</code> as well. We can just do nothing in that case.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">disconnected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>enter</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>disconnected</span><span class="z-punctuation z-separator z-object z-elixir">,</span> _data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>keep_state_and_data</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>The enter callback is called for every state transition, so we need to handle it in the <code>:connected</code> state as well. We don't want to do anything when entering that state.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">connected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>enter</span><span class="z-punctuation z-separator z-object z-elixir">,</span> _old_state<span class="z-punctuation z-separator z-object z-elixir">,</span> _data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>keep_state_and_data</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<h2 id="timeouts-for-back-offs"><a class="zola-anchor" href="#timeouts-for-back-offs" aria-label="Anchor link for: timeouts-for-back-offs">Timeouts for back-offs</a></h2>
<p>We've now got a pretty neat connection process that holds the TCP connection to our database and is able to reply to clients regardless of the state of such connection. However, in the code we built we try to reconnect as soon as the connection goes down or we fail to connect. This is usually a terrible idea, because if a connection goes down there's a good chance it won't be up right away, especially if we also fail to reconnect. A common technique to avoid frequent connection attempts is to wait a <strong>back-off period</strong> before attempting reconnections. When the connection goes down or we fail to connect, we'll wait a few hundred milliseconds before trying again.</p>
<p><code>:gen_statem</code> has the perfect tool to implement this: <strong>timeouts</strong>. One of the possible actions you can return from state functions is <code>{:timeout, timeout_name}</code>, which you can use to set a timeout with some term attached to it after a given amount of time. When the timeout expires, an event of type <code>{:timeout, timeout_name}</code> is fired.</p>
<p>Let's start by setting the timeout when we enter the disconnected state.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">disconnected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>enter</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connected</span><span class="z-punctuation z-separator z-object z-elixir">,</span> data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">  <span class="z-punctuation z-definition z-comment z-elixir">#</span> Same as before: logging, replying to
</span></span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">  <span class="z-punctuation z-definition z-comment z-elixir">#</span> waiting clients, resetting the data.
</span></span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  actions <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>timeout</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>reconnect</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-numeric z-elixir">500</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-language z-elixir">nil</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">  <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>keep_state</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> data<span class="z-punctuation z-separator z-sequence z-elixir">,</span> actions<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>Our timeout will fire after 500 milliseconds We use <code>nil</code> as its term since we're not carrying any information alongside the timeout other than its name (<code>:reconnect</code>). When the timeout expires, we need to handle it in <code>disconnected/3</code>:</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">disconnected</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>timeout</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>reconnect</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-object z-elixir">,</span> _content<span class="z-punctuation z-separator z-object z-elixir">,</span> data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  actions <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_event</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>internal</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connect</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">  <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>keep_state</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> data<span class="z-punctuation z-separator z-sequence z-elixir">,</span> actions<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>When the <code>:reconnect</code> timeout is fired, we just fire the internal <code>:connect</code> event so that we end up trying to reconnect. This removes repetition in the code and hides the plumbing of setting up timeouts manually.</p>
<h3 id="exponential-and-random-back-off"><a class="zola-anchor" href="#exponential-and-random-back-off" aria-label="Anchor link for: exponential-and-random-back-off">Exponential and random back-off</a></h3>
<p>Without going too much into detail, a fixed back-off time might not be the best idea. Imagine you have one hundred TCP connections established with the database. If the database goes down, all those connections will go down at the same time and will try to reconnect every 500 milliseconds, all at the <em>same time</em>. Part of the fix is to increase the back-off exponentially so that we can avoid situations where the database is down for a while and all connections try to reconnect very often. Then, we can add some random interval of time before reconnecting for each connection so that we avoid all the connections trying to reconnect at the same time. In code, the formula for the next back-off (given the previous back-off) can be something like:</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir">next_backoff <span class="z-keyword z-operator z-assignment z-elixir">=</span> round<span class="z-punctuation z-section z-function z-elixir">(</span>previous_backoff <span class="z-keyword z-operator z-arithmetic z-elixir">*</span> <span class="z-constant z-numeric z-elixir">2</span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span><span class="z-source z-elixir">next_backoff <span class="z-keyword z-operator z-arithmetic z-elixir">+</span> <span class="z-entity z-name z-class z-elixir">Enum</span><span class="z-punctuation z-separator z-method z-elixir">.</span>random<span class="z-punctuation z-section z-function z-elixir">(</span><span class="z-keyword z-operator z-arithmetic z-elixir">-</span><span class="z-constant z-numeric z-elixir">1000</span><span class="z-keyword z-operator z-range z-elixir">..</span><span class="z-constant z-numeric z-elixir">1000</span><span class="z-punctuation z-section z-function z-elixir">)</span>
</span></code></pre>
<h2 id="dynamic-state"><a class="zola-anchor" href="#dynamic-state" aria-label="Anchor link for: dynamic-state">Dynamic state</a></h2>
<p>The last feature of <code>:gen_statem</code> that I want to explore is <strong>dynamic state</strong>. Let's see how that could be needed in our state machine. Right now, the <code>:socket</code> field in the data is only present in the <code>:connected</code> state and <code>nil</code> the rest of the time. This information perfectly mirrors the state but it's encoded in the data and has to be managed side by side with the state and state transitions. It would be nice if we could stick the socket alongside the <code>:connected</code> state, wouldn't it? Well, we can do exactly that with "handle event" functions instead of state functions. With "handle event" functions, the state is not a simple atom (like <code>:connected</code> or <code>:disconnected</code>) anymore, but it can be any term. However, this means we can't use functions to represent the state: we'll have to use a common <code>handle_event/4</code> callback to handle all events in all state. We'll pattern match on the state to mimic what we were essentially doing with the names of the functions.</p>
<p>The first thing to do to use "handle event" functions is change <code>:state_functions</code> to <code>:handle_event_function</code> in <code>callback_mode/0</code>:</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-variable z-other z-module z-elixir"><span class="z-keyword z-operator z-definition z-constant z-elixir">@</span>impl</span> <span class="z-constant z-language z-elixir">true</span>
</span><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">callback_mode</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>handle_event_function</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>state_enter</span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>We won't rewrite the whole state machine, but just a small snippet. Let's see how we can now handle the internal <code>:connect</code> event in the <code>:disconnected</code> state. For the <code>:disconnected</code> state, we'll use the <code>:disconnected</code> atom since we don't want to carry any information with it.</p>
<pre data-lang="elixir" class="language-elixir z-code"><code class="language-elixir" data-lang="elixir"><span class="z-source z-elixir"><span class="z-meta z-function z-elixir"><span class="z-keyword z-control z-module z-elixir">def</span> <span class="z-entity z-name z-function z-public z-elixir">handle_event</span><span class="z-punctuation z-definition z-parameters z-elixir">(</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>internal</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connect</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>disconnected</span><span class="z-punctuation z-separator z-object z-elixir">,</span> data<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-module z-elixir">do</span></span>
</span><span class="z-source z-elixir">  socket_opts <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>binary</span><span class="z-punctuation z-separator z-object z-elixir">,</span> <span class="z-constant z-other z-keywords z-elixir">active<span class="z-punctuation z-definition z-constant z-elixir">:</span></span> <span class="z-constant z-language z-elixir">true</span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">case</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>gen_tcp</span><span class="z-punctuation z-separator z-method z-elixir">.</span>connect<span class="z-punctuation z-section z-function z-elixir">(</span>data<span class="z-punctuation z-separator z-method z-elixir">.</span>host<span class="z-punctuation z-separator z-object z-elixir">,</span> data<span class="z-punctuation z-separator z-method z-elixir">.</span>port<span class="z-punctuation z-separator z-object z-elixir">,</span> socket_opts<span class="z-punctuation z-section z-function z-elixir">)</span> <span class="z-keyword z-control z-elixir">do</span>
</span><span class="z-source z-elixir">    <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>ok</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> socket<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-arrow z-elixir">-&gt;</span>
</span><span class="z-source z-elixir">      <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_state</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connected</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> socket<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> data<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">
</span><span class="z-source z-elixir">    <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>error</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> error<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span> <span class="z-keyword z-operator z-arrow z-elixir">-&gt;</span>
</span><span class="z-source z-elixir"><span class="z-comment z-line z-number-sign z-elixir">      <span class="z-punctuation z-definition z-comment z-elixir">#</span> Same as before.
</span></span><span class="z-source z-elixir">      actions <span class="z-keyword z-operator z-assignment z-elixir">=</span> <span class="z-punctuation z-section z-array z-elixir">[</span><span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>next_event</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>internal</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> <span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>connect</span><span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span><span class="z-punctuation z-section z-array z-elixir">]</span>
</span><span class="z-source z-elixir">      <span class="z-meta z-sequence z-tuple z-elixir"><span class="z-punctuation z-section z-sequence z-begin z-elixir">{</span><span class="z-constant z-other z-symbol z-elixir"><span class="z-punctuation z-definition z-constant z-elixir">:</span>keep_state_and_data</span><span class="z-punctuation z-separator z-sequence z-elixir">,</span> actions<span class="z-punctuation z-section z-sequence z-end z-elixir">}</span></span>
</span><span class="z-source z-elixir">  <span class="z-keyword z-control z-elixir">end</span>
</span><span class="z-source z-elixir"><span class="z-keyword z-control z-elixir">end</span>
</span></code></pre>
<p>Now, instead of moving to the <code>:connected</code> state in case of successful connection, we move to the <code>{:connected, socket}</code> state. This means that the socket is tied to the "connected" state and doesn't exist in the <code>:disconnected</code> state.</p>
<p>"Handle event" functions are powerful. They set <code>:gen_statem</code> aside from its previous version, <a href="http://erlang.org/doc/man/gen_fsm.html"><code>:gen_fsm</code></a> (which is now deprecated). <code>:gen_fsm</code> would only let users implement <strong>finite-state machines</strong> (hence the <code>fsm</code> in the module name), but <code>:gen_statem</code> with "handle event" functions lets users implement a generic <a href="https://en.wikipedia.org/wiki/Transition_system">transition system</a>.</p>
<h2 id="conclusion"><a class="zola-anchor" href="#conclusion" aria-label="Anchor link for: conclusion">Conclusion</a></h2>
<p>In this article, we explored a way to build processes acting as persistent connections to the outside world using <code>:gen_statem</code>. We learned how to build a real-world state machine and how to use a bunch of features provided by <code>:gen_statem</code> to avoid repetition and simplify our implementation. For more information on the TCP interaction bits of this article, check out <a href="https://andrealeopardi.com/posts/handling-tcp-connections-in-elixir">"Handling TCP connections in Elixir"</a>. If you're interested in the reasoning behind the design of the persistent connection, refer to <a href="https://ferd.ca/it-s-about-the-guarantees.html">"It's about the guarantees"</a>.</p>
<p>If you're interested in the whole code for the state machine that we built, you can find it as <a href="https://gist.github.com/whatyouhide/e7531e10128af58b9830af8938eae478">a Gist</a>. In the Gist there are both the Elixir version we built and an Erlang version if you're more comfortable with Erlang.</p>
</div>

    <time class="posted-at" datetime="2019-04-14">
      Written on April 14, 2019
      
    </time>

    <script src="https://giscus.app/client.js"
        data-repo="whatyouhide/whatyouhide.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkxODQwNDQxNzQ="
        data-category="General"
        data-category-id="DIC_kwDOCvhKjs4CY-gd"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
  </article>
</div>


        <footer>
    <div class="icons">
        <a href="mailto:hi@andrealeopardi.com">
            <picture>
              <img id="icon-email"
                   class="footer-icon"
                   src="/assets/icons/email.png"
                   alt="Hand-drawn icon of a letter envelope"
                   title="Email" />
            </picture>
        </a>

        <a href="https://github.com/whatyouhide" target="_blank">
            <picture>
              <img id="icon-github"
                   class="footer-icon"
                   src="/assets/icons/github.png"
                   alt="Hand-drawn icon of the GitHub logo"
                   title="GitHub" />
            </picture>
        </a>

        <a href="https://twitter.com/whatyouhide" target="_blank">
            <picture>
              <img id="icon-twitter"
                   class="footer-icon"
                   src="/assets/icons/twitter.png"
                   alt="Hand-drawn icon of the Twitter logo"
                   title="Twitter" />
            </picture>
        </a>

        <a href="/feed.xml">
            <picture>
              <img id="icon-rss"
                   class="footer-icon"
                   src="/assets/icons/rss.png"
                   alt="Hand-drawn icon of the RSS logo"
                   title="RSS feed" />
            </picture>
        </a>
    </div>
</footer>

    </div>
</body>

</html>
